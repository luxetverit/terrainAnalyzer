import datetime
import io
import platform

import matplotlib.patches as mpatches
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import pyvista as pv
import streamlit as st
from matplotlib.colors import BoundaryNorm, LightSource, ListedColormap
from matplotlib.patches import Polygon, Rectangle
from scipy.interpolate import griddata
from stpyvista import stpyvista

from utils.color_palettes import get_landcover_colormap
from utils.theme_util import apply_styles

# --- 0. Matplotlib Font Configuration ---
if platform.system() == 'Windows':
    plt.rc('font', family='Malgun Gothic')
else:
    # For Linux, ensure 'NanumGothic' is installed.
    # sudo apt-get install -y fonts-nanum*
    plt.rc('font', family='NanumGothic')
plt.rcParams['axes.unicode_minus'] = False

# --- 1. Page Configuration and Styling ---
st.set_page_config(page_title="Î∂ÑÏÑù Í≤∞Í≥º - ÏßÄÌòï Î∂ÑÏÑù ÏÑúÎπÑÏä§",
                   page_icon="üìä",
                   layout="wide",
                   initial_sidebar_state="collapsed")
apply_styles()

# --- 2. Session State Check ---
if 'dem_results' not in st.session_state:
    st.warning("Î∂ÑÏÑù Í≤∞Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§. Ìôà ÌéòÏù¥ÏßÄÎ°ú ÎèåÏïÑÍ∞Ä Î∂ÑÏÑùÏùÑ Î®ºÏ†Ä Ïã§ÌñâÌï¥Ï£ºÏÑ∏Ïöî.")
    if st.button("ÌôàÏúºÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞"):
        st.switch_page("app.py")
    st.stop()

# --- 3. Helper functions (v7 Styling - Final Layout) ---


def add_north_arrow(ax, x=0.95, y=0.95, size=0.05):
    """AxesÏùò Ïö∞Ï∏° ÏÉÅÎã®Ïóê ÎÇòÏπ®Î∞òÌòï Î∞©ÏúÑÎ•º Ï∂îÍ∞ÄÌï©ÎãàÎã§. """
    north_part = Polygon([[x, y], [x - size * 0.4, y - size], [x, y - size*0.8]],
                         facecolor='black', edgecolor='black', transform=ax.transAxes)
    south_part = Polygon([[x, y], [x + size * 0.4, y - size], [x, y - size*0.8]],
                         facecolor='#666666', edgecolor='black', transform=ax.transAxes)
    ax.add_patch(north_part)
    ax.add_patch(south_part)
    ax.text(x, y + size*0.2, 'N', ha='center', va='center',
            fontsize='large', fontweight='bold', transform=ax.transAxes)


def add_scalebar_vector(ax, dx=1.0):
    """AxesÏùò Ï¢åÏ∏° ÌïòÎã®Ïóê Ï∂ïÏ≤ôÍ≥º ÎπÑÏú®ÏùÑ Ï∂îÍ∞ÄÌï©ÎãàÎã§. (Î≤°ÌÑ∞Ïö©)"""
    x_min, x_max = ax.get_xlim()
    y_min, y_max = ax.get_ylim()

    # 1. Í∑∏ÎûòÌîΩ Ï∂ïÏ≤ô Í≥ÑÏÇ∞ Î∞è Í∑∏Î¶¨Í∏∞
    map_width_m = (x_max - x_min) * dx
    target_length = map_width_m * 0.5
    powers = 10**np.floor(np.log10(target_length))
    base = np.ceil(target_length / powers)
    if base > 5:
        base = 5
    elif base > 2:
        base = 2
    nice_len_m = base * powers

    num_segments = 4
    segment_m = nice_len_m / num_segments
    segment_data = segment_m / dx
    bar_height = (y_max - y_min) * 0.01

    x_pos = x_min + (x_max - x_min) * 0.05
    y_pos = y_min + (y_max - y_min) * 0.05

    for i in range(num_segments):
        color = 'black' if i % 2 == 0 else 'white'
        rect = Rectangle((x_pos + i * segment_data, y_pos), segment_data, bar_height,
                         edgecolor='black', facecolor=color, lw=1, zorder=10)
        ax.add_patch(rect)
        ax.text(x_pos + i * segment_data, y_pos - bar_height*0.5, f'{int(i * segment_m)}',
                ha='center', va='top', fontsize='small', zorder=10)

    ax.text(x_pos + nice_len_m / dx, y_pos - bar_height*0.5, f'{int(nice_len_m)} m',
            ha='center', va='top', fontsize='small', zorder=10)

    # 2. ÎπÑÏú® Ï∂ïÏ≤ô Í≥ÑÏÇ∞ Î∞è ÌëúÏãú
    fig = ax.get_figure()
    ax_pos = ax.get_position()
    fig_width_inch = fig.get_size_inches()[0]
    ax_width_inch = ax_pos.width * fig_width_inch
    m_per_inch = map_width_m / ax_width_inch
    # ratio_scale = m_per_inch / 0.0254
    ax.text(x_pos + (nice_len_m / dx) / 2, y_pos + bar_height * 2.5, '',
            ha='center', va='bottom', fontsize='medium', zorder=10)

def calculate_accurate_scalebar_params(pixel_size, img_shape, target_size_mm, fig, ax):
    """Ïã§Ï†ú axes Ï†ïÎ≥¥Î•º ÏÇ¨Ïö©Ìïú Ï†ïÌôïÌïú Ïä§ÏºÄÏùºÎ∞î Í≥ÑÏÇ∞"""
    fig_width_inch, fig_height_inch = fig.get_size_inches()
    ax_bbox = ax.get_position()

    img_width_fig = ax_bbox.width
    img_height_fig = ax_bbox.height

    img_height_pixels, img_width_pixels = img_shape

    img_width_inch = img_width_fig * fig_width_inch
    pixels_per_inch = img_width_pixels / img_width_inch

    target_size_inch = target_size_mm / 25.4
    target_pixels = target_size_inch * pixels_per_inch
    real_distance_m = target_pixels * pixel_size

    if real_distance_m < 100:
        scale_distance_m = round(real_distance_m / 50) * 50
        if scale_distance_m == 0:
            scale_distance_m = 50
        unit = 'm'
        scale_value = scale_distance_m
    elif real_distance_m < 1000:
        scale_distance_m = round(real_distance_m / 100) * 100
        unit = 'm'
        scale_value = scale_distance_m
    elif real_distance_m < 5000:
        scale_distance_km = round(real_distance_m / 500) * 0.5
        scale_distance_m = scale_distance_km * 1000
        unit = 'km'
        scale_value = scale_distance_km
    else:
        scale_distance_km = round(real_distance_m / 1000)
        scale_distance_m = scale_distance_km * 1000
        unit = 'km'
        scale_value = scale_distance_km

    actual_scalebar_width_fig = (
        scale_distance_m / pixel_size) / pixels_per_inch / fig_width_inch

    return {
        'length': scale_value,
        'units': unit,
        'segments': 2,
        'target_size_mm': target_size_mm,
        'real_distance_m': scale_distance_m,
        'scalebar_width_fig': actual_scalebar_width_fig
    }


def draw_accurate_scalebar(fig, ax, pixel_size, scale_params, img_shape):
    """Ï†ïÌôïÌïú Ï∂ïÏ≤ô Î∞òÏòÅ Ïä§ÏºÄÏùºÎ∞î"""
    total_length = scale_params['length']
    units = scale_params['units']
    segments = scale_params['segments']
    scalebar_width_fig = scale_params['scalebar_width_fig']

    start_x_fig = 0.1
    start_y_fig = 0.02
    bar_height_fig = 0.008

    bg_width_fig = scalebar_width_fig + 0.01
    bg_height_fig = bar_height_fig * 2 + 0.03

    bg_rect = Rectangle((start_x_fig - 0.005, start_y_fig - 0.005),
                        bg_width_fig, bg_height_fig,
                        facecolor='white', edgecolor='none', linewidth=0,
                        alpha=0.9, transform=fig.transFigure)
    fig.patches.append(bg_rect)

    segment_width_fig = scalebar_width_fig / segments
    segment_value = total_length / segments

    for i in range(segments):
        x_fig = start_x_fig + i * segment_width_fig

        color1 = 'black' if i % 2 == 0 else 'white'
        rect1 = Rectangle((x_fig, start_y_fig + bar_height_fig),
                          segment_width_fig, bar_height_fig,
                          facecolor=color1, edgecolor='black', linewidth=0.5,
                          transform=fig.transFigure)
        fig.patches.append(rect1)

        color2 = 'white' if i % 2 == 0 else 'black'
        rect2 = Rectangle((x_fig, start_y_fig),
                          segment_width_fig, bar_height_fig,
                          facecolor=color2, edgecolor='black', linewidth=0.5,
                          transform=fig.transFigure)
        fig.patches.append(rect2)

        text_x_fig = x_fig + segment_width_fig
        text_y_fig = start_y_fig + bar_height_fig * 2 + 0.005

        segment_val = (i + 1) * segment_value

        if units == 'km':
            if segment_val != int(segment_val):
                text_label = f'{segment_val:.1f}'
            else:
                text_label = f'{int(segment_val)}'
        else:
            text_label = f'{int(segment_val)}'

        if i == segments - 1:
            text_label += units

        fig.text(text_x_fig, text_y_fig, text_label,
                 ha='center', va='bottom', fontsize=9, fontweight='bold',
                 color='black', transform=fig.transFigure)

    fig.text(start_x_fig, start_y_fig + bar_height_fig * 2 + 0.005, '0',
             ha='center', va='bottom', fontsize=9, fontweight='bold',
             color='black', transform=fig.transFigure)


def create_hillshade(data, azimuth=315, altitude=45):
    """Í≥†ÌíàÏßà ÏùåÏòÅÍ∏∞Î≥µÎèÑ(Hillshade) ÏÉùÏÑ± (numpy.gradient ÏÇ¨Ïö©)"""
    # NaN Í∞í Ï≤òÎ¶¨: Í≥ÑÏÇ∞Ïóê ÏòÅÌñ•ÏùÑ Ï£ºÏßÄ ÏïäÎèÑÎ°ù Ïú†Ìö®Ìïú ÎßàÏä§ÌÅ¨ ÏÉùÏÑ±
    valid_mask = ~np.isnan(data)
    if not np.any(valid_mask):
        return np.ones_like(data) * 0.5  # Îç∞Ïù¥ÌÑ∞Í∞Ä Î™®Îëê NaNÏù¥Î©¥ Ï§ëÍ∞Ñ Î∞ùÍ∏∞ Î∞òÌôò

    # Í≤ΩÏÇ¨ÎèÑÏôÄ Í≤ΩÏÇ¨Ìñ• Í≥ÑÏÇ∞ (y, x ÏàúÏÑú Ï£ºÏùò)
    dy, dx = np.gradient(data)

    # Í≤ΩÏÇ¨Í∞Å Í≥ÑÏÇ∞ (ÎùºÎîîÏïà)
    slope = np.arctan(np.sqrt(dx**2 + dy**2))

    # Í≤ΩÏÇ¨Ìñ• Í≥ÑÏÇ∞ (ÎùºÎîîÏïà, Î∂ÅÏ™Ω 0ÎèÑ Í∏∞Ï§Ä)
    aspect = np.arctan2(-dx, dy)

    # ÌÉúÏñë Í∞ÅÎèÑÎ•º ÎùºÎîîÏïàÏúºÎ°ú Î≥ÄÌôò
    azimuth_rad = np.radians(azimuth)
    altitude_rad = np.radians(altitude)

    # Hillshade Í≥ÑÏÇ∞ Í≥µÏãù
    hillshade = (np.sin(altitude_rad) * np.sin(np.pi/2 - slope) +
                 np.cos(altitude_rad) * np.cos(np.pi/2 - slope) *
                 np.cos(azimuth_rad - aspect))

    # 0~1 Î≤îÏúÑÎ°ú Ï†ïÍ∑úÌôî
    hillshade = np.clip(hillshade, 0, 1)

    # ÏõêÎûò NaNÏù¥ÏóàÎçò ÏúÑÏπòÎäî Ï§ëÍ∞Ñ Î∞ùÍ∏∞Î°ú ÏÑ§Ï†ï
    hillshade[~valid_mask] = 0.5

    return hillshade


def create_padded_fig_ax(figsize=(10, 10)):
    """ÏÉÅÌïòÏóê Ïó¨Î∞±Ïù¥ ÏûàÎäî FigureÏôÄ AxesÎ•º ÏÉùÏÑ±Ìï©ÎãàÎã§. """
    fig, ax = plt.subplots(figsize=figsize)
    return fig, ax


interval_candidates = [1, 2, 3, 5, 10, 15, 20, 25, 50, 100, 150, 200, 500]

# ÌëúÍ≥† Ï†ÑÏö© ÏÇ¨Ïö©Ïûê Ï†ïÏùò ÏÉâÏÉÅ (from hillsade.py)
elevation_colors = {
    10: ['#66CDAA', '#DDF426', '#71B800', '#558C00', '#F29300', '#981200', '#9C1C1C', '#955050', '#9C9B9B', '#FFFAFA']
}

def generate_custom_intervals(min_val, max_val, divisions):
    """ÏÇ¨Ïö©Ïûê Ï†ïÏùò Íµ¨Í∞Ñ ÏÉùÏÑ± (hillsade.py Î°úÏßÅ)"""
    # divisionsÎäî ÎùºÎ≤®Ïùò Í∞úÏàòÎ•º ÏùòÎØ∏
    if max_val - min_val == 0:
        # Îç∞Ïù¥ÌÑ∞ Í∞íÏù¥ Î™®Îëê Í∞ôÏùÑ Í≤ΩÏö∞
        labels = [f"{min_val:.1f}"] * divisions
        interval = 0
        start = min_val
        return labels, interval, start

    diff = max_val - min_val
    div = divisions - 2  # 'ÎØ∏Îßå', 'Ï¥àÍ≥º'Î•º Ï†úÏô∏Ìïú Ï§ëÍ∞Ñ Íµ¨Í∞ÑÏùò Ïàò
    if div <= 0:  # divisionsÍ∞Ä 2 Ïù¥ÌïòÏùº Í≤ΩÏö∞
        div = 1

    target_interval = diff / div
    # Î™©Ìëú Íµ¨Í∞ÑÍ≥º Í∞ÄÏû• Í∞ÄÍπåÏö¥ 'nice'Ìïú Íµ¨Í∞Ñ ÌõÑÎ≥¥Î•º Ï∞æÏùå
    sorted_candidates = sorted(
        interval_candidates, key=lambda x: abs(x - target_interval))

    # Í∞ÄÏû• Ï†ÅÌï©Ìïú ÌõÑÎ≥¥Î•º ÏÑ†ÌÉù (Îã®, diffÎ≥¥Îã§ ÌÅ∞ ÌõÑÎ≥¥Îäî Ï†úÏô∏)
    best_interval = sorted_candidates[0]
    for candidate in sorted_candidates:
        if candidate * div > diff * 0.5:  # ÎÑàÎ¨¥ Í∞ÑÍ≤©Ïù¥ ÎÑìÏñ¥ÏßÄÏßÄ ÏïäÎèÑÎ°ù ÌïÑÌÑ∞ÎßÅ
            best_interval = candidate
            break

    mid_val = min_val + diff / 2
    mid_aligned = round(mid_val / best_interval) * best_interval
    start = mid_aligned - best_interval * (div // 2)

    # ÎùºÎ≤® ÏÉùÏÑ±
    labels = [f"{start} ÎØ∏Îßå"]
    for i in range(div):
        lo = start + i * best_interval
        hi = lo + best_interval
        labels.append(f"{lo}~{hi}")
    labels.append(f"{hi} Ï¥àÍ≥º")

    return labels, best_interval, start


def adjust_ax_limits(ax, y_pad_fraction=0.15, x_pad_fraction=0.05):
    """AxesÏùò YÏ∂ï Î≤îÏúÑÎ•º ÌôïÏû•ÌïòÏó¨ Ïó¨Î∞±ÏùÑ ÎßåÎì≠ÎãàÎã§. """
    x_min, x_max = ax.get_xlim()
    y_min, y_max = ax.get_ylim()
    x_range = x_max - x_min
    y_range = y_max - y_min
    ax.set_xlim(x_min - x_range * x_pad_fraction,
                x_max + x_range * x_pad_fraction)
    ax.set_ylim(y_min - y_range * y_pad_fraction,
                y_max + y_range * y_pad_fraction)


# --- 3. Data Loading from Session ---
dem_results = st.session_state.dem_results
selected_types = st.session_state.get('selected_analysis_types', [])
matched_sheets = st.session_state.get('matched_sheets', [])
analysis_date = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")

# --- 4. Page Header ---
st.markdown('''<div class="page-header"><h1>Î∂ÑÏÑù Í≤∞Í≥º</h1><p>ÏÑ†ÌÉùÌïòÏã† Ìï≠Î™©Ïóê ÎåÄÌïú ÏßÄÌòï Î∂ÑÏÑù Í≤∞Í≥ºÏûÖÎãàÎã§.</p></div>''',
            unsafe_allow_html=True)

# --- 5. 3D Visualization (Ï£ºÏÑù Ï≤òÎ¶¨) ---


# """
# st.markdown("### üßä 3D ÌÜµÌï© Î∂ÑÏÑù Í≤∞Í≥º")
# dem_analysis_types = [t for t in selected_types if t in [
#     'elevation', 'slope', 'aspect']]
# if not dem_analysis_types:
#     st.info("3D ÏãúÍ∞ÅÌôîÎ•º ÏúÑÌïú Î∂ÑÏÑù Ìï≠Î™©(ÌëúÍ≥†, Í≤ΩÏÇ¨, Í≤ΩÏÇ¨Ìñ•)Ïù¥ ÏÑ†ÌÉùÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.")
# else:
#     dem_grid = dem_results.get('elevation', {}).get('grid')
#     if dem_grid is None or np.all(np.isnan(dem_grid)):
#         st.warning("3D ÏãúÍ∞ÅÌôîÎ•º ÏúÑÌïú ÌëúÍ≥† Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.")
#     else:
#         with st.spinner("3D Î™®Îç∏ÏùÑ Î†åÎçîÎßÅÌïòÎäî Ï§ëÏûÖÎãàÎã§..."):
#             try:
#                 x = np.arange(dem_grid.shape[1])
#                 y = np.arange(dem_grid.shape[0])
#                 xv, yv = np.meshgrid(x, y)

#                 grid_pv = pv.StructuredGrid(xv, yv, dem_grid)
#                 grid_pv["Elevation"] = dem_grid.ravel(order="F")
#                 if 'slope' in dem_results:
#                     grid_pv["Slope (¬∞)"] = dem_results['slope']['grid'].ravel(
#                         order="F")
#                 if 'aspect' in dem_results:
#                     grid_pv["Aspect (¬∞)"] = dem_results['aspect']['grid'].ravel(
#                         order="F")

#                 grid_pv.warp_by_scalar(
#                     scalars="Elevation", factor=0.5, inplace=True)
#                 plotter = pv.Plotter(
#                     shape=(1, len(dem_analysis_types)), border=False, window_size=[1200, 400])
#                 scalar_bar_args = {
#                     'title_font_size': 16, 'label_font_size': 12, 'vertical': True,
#                     'position_x': 0.75, 'position_y': 0.1, 'height': 0.8, 'width': 0.08,
#                     'n_labels': 7, 'fmt': '%.2f', 'shadow': True, 'font_family': 'arial',
#                 }

#                 for i, analysis_type in enumerate(dem_analysis_types):
#                     plotter.subplot(0, i)
#                     var_name = {"elevation": "Elevation", "slope": "Slope (¬∞)", "aspect": "Aspect (¬∞)"}[
#                         analysis_type]
#                     cmap = {"elevation": "terrain", "slope": "viridis",
#                             "aspect": "hsv"}[analysis_type]

#                     plotter.add_text(var_name, font_size=12)
#                     mesh = grid_pv.copy()
#                     mesh.set_active_scalars(var_name)
#                     specific_args = scalar_bar_args.copy()
#                     specific_args['title'] = var_name
#                     plotter.add_mesh(mesh, scalars=var_name, cmap=cmap, show_scalar_bar=True,
#                                      scalar_bar_args=specific_args, nan_opacity=0.0)
#                     plotter.camera_position = 'iso'

#                 plotter.background_color = 'white'
#                 stpyvista(plotter, key="pv_3d_view")
#             except Exception as e:
#                 st.error(f"3D Î™®Îç∏ ÏÉùÏÑ± Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {e}")
# """

# --- 6. 2D Analysis Results (in Tabs) ---
st.markdown("### üìà 2D ÏÉÅÏÑ∏ Î∂ÑÏÑù Í≤∞Í≥º")
analysis_map = {
    'elevation': {'title': "ÌëúÍ≥† Î∂ÑÏÑù", 'unit': "m", 'binned_label': "ÌëúÍ≥† Íµ¨Í∞ÑÎ≥Ñ Î©¥Ï†Å"},
    'slope': {'title': "Í≤ΩÏÇ¨ Î∂ÑÏÑù", 'unit': "¬∞", 'binned_label': "Í≤ΩÏÇ¨ Íµ¨Í∞ÑÎ≥Ñ Î©¥Ï†Å"},
    'aspect': {'title': "Í≤ΩÏÇ¨Ìñ• Î∂ÑÏÑù", 'unit': "¬∞", 'binned_label': "Í≤ΩÏÇ¨Ìñ• Íµ¨Í∞ÑÎ≥Ñ Î©¥Ï†Å"},
    'soil': {'title': "ÌÜ†ÏñëÎèÑ Î∂ÑÏÑù", 'unit': "m¬≤", 'binned_label': "ÌÜ†Ïñë Ï¢ÖÎ•òÎ≥Ñ Î©¥Ï†Å", 'class_col': 'soilsy', 'legend_title': 'ÌÜ†ÏÑ±'},
    'hsg': {'title': "ÏàòÎ¨∏ÌïôÏ†Å ÌÜ†ÏñëÍµ∞", 'unit': "m¬≤", 'binned_label': "HSG Îì±Í∏âÎ≥Ñ Î©¥Ï†Å", 'class_col': 'hg', 'legend_title': 'HSG Îì±Í∏â'},
    'landcover': {'title': "ÌÜ†ÏßÄÌîºÎ≥µÎèÑ", 'unit': "m¬≤", 'binned_label': "ÌÜ†ÏßÄÌîºÎ≥µÎ≥Ñ Î©¥Ï†Å", 'class_col': 'l2_name', 'legend_title': 'ÌÜ†ÏßÄÌîºÎ≥µ'},
}
valid_selected_types = [t for t in selected_types if t in dem_results]

if not valid_selected_types:
    st.info("ÌëúÏãúÌï† 2D Î∂ÑÏÑù Í≤∞Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§.")
else:
    tab_titles = [analysis_map.get(t, {}).get('title', t)
                  for t in valid_selected_types]
    tabs = st.tabs(tab_titles)
    for i, analysis_type in enumerate(valid_selected_types):
        with tabs[i]:
            results = dem_results[analysis_type]
            stats = results.get('stats')
            grid = results.get('grid')
            gdf = results.get('gdf')

            if stats:
                st.markdown("#### ÏöîÏïΩ ÌÜµÍ≥Ñ")
                cols = st.columns(3)
                cols[0].metric(
                    label="ÏµúÏÜåÍ∞í", value=f"{stats.get('min', 0):.2f} {analysis_map.get(analysis_type, {}).get('unit', '')}")
                cols[1].metric(
                    label="ÏµúÎåÄÍ∞í", value=f"{stats.get('max', 0):.2f} {analysis_map.get(analysis_type, {}).get('unit', '')}")
                cols[2].metric(
                    label="ÌèâÍ∑†Í∞í", value=f"{stats.get('mean', 0):.2f} {analysis_map.get(analysis_type, {}).get('unit', '')}")
                st.markdown("---_---")

                title = analysis_map.get(analysis_type, {}).get('title', analysis_type)
                with st.spinner(f"'{title}' Î∂ÑÏÑùÎèÑÎ•º ÏÉùÏÑ±ÌïòÎäî Ï§ëÏûÖÎãàÎã§..."):
                    # ÌëúÍ≥† Î∂ÑÏÑù: QGIS Ïä§ÌÉÄÏùº Îì±Í∏â Î≤îÎ°Ä + ÏùåÏòÅÍ∏∞Î≥µÎèÑ Ïò§Î≤ÑÎ†àÏù¥ ÏòµÏÖò
                    if analysis_type == 'elevation':

                        # --- ÏãúÍ∞ÅÌôî ÏòµÏÖò ---
                        use_hillshade = st.toggle("ÏùåÏòÅÍ∏∞Î≥µÎèÑ Ï§ëÏ≤©", value=True,
                                                  help="ÏßÄÌòïÏùò ÏûÖÏ≤¥Í∞êÏùÑ ÌëúÌòÑÌïòÍ∏∞ ÏúÑÌï¥ ÏùåÏòÅÍ∏∞Î≥µÎèÑÎ•º ÌëúÍ≥† Î∂ÑÏÑùÎèÑÏóê Í≤πÏ≥êÏÑú ÌëúÏãúÌï©ÎãàÎã§.")

                        fig, ax = create_padded_fig_ax(figsize=(10, 8))

                        min_val, max_val = stats.get('min', 0), stats.get('max', 1)

                        # hillsade.py Ïä§ÌÉÄÏùº Î≤îÎ°Ä Î∞è Íµ¨Í∞Ñ ÏÉùÏÑ±
                        divisions = 10
                        legend_labels, interval, start = generate_custom_intervals(
                            min_val, max_val, divisions)

                        # BoundaryNormÏùÑ ÏúÑÌïú Î†àÎ≤®(Íµ¨Í∞Ñ Í≤ΩÍ≥Ñ) ÏÑ§Ï†ï
                        # NÍ∞úÏùò Íµ¨Í∞ÑÏùÄ N+1Í∞úÏùò Í≤ΩÍ≥ÑÍ∞Ä ÌïÑÏöîÌï®
                        div = divisions - 2
                        levels = [start + i * interval for i in range(div + 1)]
                        levels = [float('-inf')] + levels + [float('inf')]

                        # ÏÇ¨Ïö©Ïûê Ï†ïÏùò ÏÉâÏÉÅ Ï†ÅÏö©
                        cmap = ListedColormap(elevation_colors[10])
                        norm = BoundaryNorm(levels, cmap.N)

                        # ÏùåÏòÅÍ∏∞Î≥µÎèÑ Ï§ëÏ≤© Î°úÏßÅ (hillsade.py Ïä§ÌÉÄÏùº)
                        if use_hillshade:
                            # 1. DEM Îç∞Ïù¥ÌÑ∞Î°úÎ∂ÄÌÑ∞ ÏùåÏòÅÍ∏∞Î≥µÎèÑ ÏÉùÏÑ±
                            hillshade = create_hillshade(grid)

                            # 2. Ïª¨Îü¨Îßµ Ï†ÅÏö©ÌïòÏó¨ RGBA Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
                            # normÏùÄ Í∞Å ÌîΩÏÖÄÏù¥ Ïñ¥Îñ§ ÏÉâÏÉÅ Íµ¨Í∞ÑÏóê ÏÜçÌïòÎäîÏßÄ Ïù∏Îç±Ïä§Î•º Î∞òÌôò
                            rgba_data = cmap(norm(grid))

                            # 3. ÏùåÏòÅ Ìö®Í≥ºÏôÄ ÏÉâÏÉÅ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìï© (RGB Ï±ÑÎÑêÏóêÎßå Ï†ÅÏö©)
                            # hillshade Í∞íÏùÑ Ï°∞Ï†ïÌïòÏó¨ ÎÑàÎ¨¥ Ïñ¥ÎëêÏõåÏßÄÏßÄ ÏïäÍ≤å Ìï® (0.5 ~ 1.2)
                            intensity = 0.7
                            hillshade_adjusted = 0.5 + hillshade * intensity

                            # RGB Ï±ÑÎÑê(0,1,2)Ïóê ÏùåÏòÅ Ìö®Í≥ºÎ•º Í≥±Ìï®
                            for i in range(3):
                                rgba_data[:, :, i] *= hillshade_adjusted

                            # 4. Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ Îç∞Ïù¥ÌÑ∞(NaN)Îäî Ìà¨Î™ÖÌïòÍ≤å Ï≤òÎ¶¨
                            valid_mask = ~np.isnan(grid)
                            rgba_data[~valid_mask, 3] = 0  # Alpha channel to 0

                            # 5. ÏµúÏ¢Ö Ïù¥ÎØ∏ÏßÄ ÌëúÏãú
                            im = ax.imshow(
                                np.clip(rgba_data, 0, 1), origin='upper')
                        else:
                            # ÏùåÏòÅÍ∏∞Î≥µÎèÑÎ•º ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÏùÑ Í≤ΩÏö∞, Í∏∞Ï°¥Ï≤òÎüº ÌëúÍ≥†ÎèÑÎßå Í∑∏Î¶¨Í∏∞
                            im = ax.imshow(np.ma.masked_invalid(
                                grid), cmap=cmap, norm=norm)

                        # Îì±Í≥†ÏÑ† Ï∂îÍ∞Ä (50m Í∞ÑÍ≤©)
                        level_interval = 50
                        start_level = np.ceil(min_val / level_interval) * level_interval
                        end_level = np.floor(max_val / level_interval) * level_interval

                        if start_level < end_level:
                            contour_levels = np.arange(start_level, end_level + 1, level_interval)
                        else:
                            contour_levels = np.linspace(min_val, max_val, 10)

                        contour = ax.contour(
                            grid, levels=contour_levels, colors='k', alpha=0.3, linewidths=0.7)

                        # Îì±Í≥†ÏÑ† ÎùºÎ≤® Ï∂îÍ∞Ä (100m Í∞ÑÍ≤©)
                        label_interval = 100
                        start_label_level = np.ceil(min_val / label_interval) * label_interval
                        end_label_level = np.floor(max_val / label_interval) * label_interval

                        if start_label_level < end_label_level:
                            label_levels = np.arange(start_label_level, end_label_level + 1, label_interval)
                        else:
                            # 100m Í∞ÑÍ≤© ÎùºÎ≤®ÏùÑ ÌëúÏãúÌï† Ïàò ÏóÜÏúºÎ©¥ Î™®Îì† Îì±Í≥†ÏÑ†Ïóê ÎùºÎ≤® ÌëúÏãú
                            label_levels = contour_levels

                        clabels = ax.clabel(contour, levels=label_levels, inline=True, fontsize=8, fmt='%.0f')
                        plt.setp(clabels, fontweight='bold')

                        ax.set_title(analysis_map[analysis_type].get(
                            'title', ''), fontsize=16, pad=20)

                        # hillsade.py Ïä§ÌÉÄÏùº Î≤îÎ°Ä ÏÉùÏÑ±
                        patches = []
                        for i in range(len(legend_labels)):
                            color = cmap(i)
                            label = f"{legend_labels[i]} m"
                            patches.append(mpatches.Patch(
                                color=color, label=label))

                        legend = ax.legend(handles=patches, title="ÌëúÍ≥† Î≤îÏúÑ (m)",
                                           bbox_to_anchor=(1.05, 1), loc='upper left',
                                           fontsize='small', frameon=True, framealpha=1,
                                           edgecolor='black')
                        legend.get_title().set_fontweight('bold')

                        adjust_ax_limits(ax)
                        add_north_arrow(ax)
                        pixel_size = st.session_state.get('pixel_size', 1.0)
                        scale_params = calculate_accurate_scalebar_params(pixel_size, grid.shape, 25, fig, ax)
                        draw_accurate_scalebar(fig, ax, pixel_size, scale_params, grid.shape)
                        ax.axis('off')

                        # PNG Îã§Ïö¥Î°úÎìúÎ•º ÏúÑÌïú Ïù¥ÎØ∏ÏßÄ Î≤ÑÌçº ÏÉùÏÑ±
                        img_buffer = io.BytesIO()
                        fig.savefig(img_buffer, format='png',
                                    bbox_inches='tight', dpi=150)
                        img_buffer.seek(0)

                        st.pyplot(fig)
                        plt.close(fig)

                        # Îã§Ïö¥Î°úÎìú Î≤ÑÌäº Ï∂îÍ∞Ä
                        file_name_suffix = "_hillshade" if use_hillshade else ""
                        st.download_button(
                            label=f"PNG Ïù¥ÎØ∏ÏßÄÎ°ú Îã§Ïö¥Î°úÎìú{' (ÏùåÏòÅÍ∏∞Î≥µÎèÑ Ìè¨Ìï®)' if use_hillshade else ''}",
                            data=img_buffer,
                            file_name=f"elevation_analysis{file_name_suffix}_{datetime.datetime.now().strftime('%Y%m%d')}.png",
                            mime="image/png"
                        )

                    # Í≤ΩÏÇ¨, Í≤ΩÏÇ¨Ìñ• Î∂ÑÏÑù: Í∏∞Ï°¥ ÌÉ≠ Ïä§ÌÉÄÏùº Ïú†ÏßÄ
                    else:
                        cmap_options = {
                            'slope': ['viridis', 'inferno', 'magma', 'RdYlGn_r'],
                            'aspect': ['hsv', 'twilight_shifted', 'twilight']
                        }
                        cmaps_to_show = cmap_options.get(
                            analysis_type, ['viridis'])
                        cmap_tabs = st.tabs([f"{cmap}" for cmap in cmaps_to_show])

                        for j, cmap in enumerate(cmaps_to_show):
                            with cmap_tabs[j]:
                                fig, ax = create_padded_fig_ax(figsize=(10, 8))
                                im = ax.imshow(
                                    np.ma.masked_invalid(grid), cmap=cmap)
                                cbar = fig.colorbar(
                                    im, ax=ax, label=analysis_map[analysis_type].get('unit', ''), shrink=0.8)
                                ax.set_title(
                                    f"{analysis_map[analysis_type].get('title', '')} - '{cmap}'")

                                adjust_ax_limits(ax)
                                add_north_arrow(ax)
                                pixel_size = st.session_state.get('pixel_size', 1.0)
                                scale_params = calculate_accurate_scalebar_params(pixel_size, grid.shape, 25, fig, ax)
                                draw_accurate_scalebar(fig, ax, pixel_size, scale_params, grid.shape)
                                ax.axis('off')
                                st.pyplot(fig)
                                plt.close(fig)

            elif gdf is not None and not gdf.empty:
                title = analysis_map.get(
                    analysis_type, {}).get('title', analysis_type)
                with st.spinner(f"'{title}' Î∂ÑÏÑùÎèÑÎ•º ÏÉùÏÑ±ÌïòÎäî Ï§ëÏûÖÎãàÎã§..."):
                    fig, ax = create_padded_fig_ax(figsize=(10, 10))
                    type_info = analysis_map.get(analysis_type, {})
                    class_col = type_info.get('class_col')

                    # Landcover custom color logic
                    if analysis_type == 'landcover':
                        # Check if color map is loaded and required columns exist
                        color_map = get_landcover_colormap()
                        if color_map and 'l2_code' in gdf.columns and 'l2_name' in gdf.columns:
                            gdf['plot_color'] = gdf['l2_code'].map(color_map)
                            # Plot with the specified colors, handling potential missing colors
                            gdf.plot(ax=ax, color=gdf['plot_color'].fillna(
                                '#FFFFFF'), linewidth=0.5, edgecolor='k')

                            # Create a custom legend
                            unique_cats = gdf[['l2_code', 'l2_name']].drop_duplicates(
                            ).sort_values(by='l2_code')
                            patches = []
                            for _, row in unique_cats.iterrows():
                                code = row['l2_code']
                                name = row['l2_name']
                                # Default to white if not in map
                                color = color_map.get(code, '#FFFFFF')
                                patch = mpatches.Patch(
                                    color=color, label=f'{name} ({code})')
                                patches.append(patch)

                            if patches:
                                ax.legend(handles=patches, title=type_info.get('legend_title', 'Î∂ÑÎ•ò'),
                                          bbox_to_anchor=(1.05, 1), loc='upper left', fontsize='small')
                        else:
                            # Fallback for landcover if custom colors fail
                            gdf.plot(column=class_col, ax=ax, legend=True, categorical=True,
                                     legend_kwds={'title': type_info.get('legend_title', 'Î∂ÑÎ•ò'), 'bbox_to_anchor': (1.05, 1), 'loc': 'upper left'})

                    # Logic for other vector types (soil, hsg)
                    else:
                        if class_col and class_col in gdf.columns:
                            gdf.plot(column=class_col, ax=ax, legend=True, categorical=True,
                                     legend_kwds={'title': type_info.get('legend_title', 'Î∂ÑÎ•ò'), 'bbox_to_anchor': (1.05, 1), 'loc': 'upper left'})
                        else:
                            gdf.plot(ax=ax)
                            if class_col:
                                st.warning(
                                    f"Ï£ºÏùò: Î∂ÑÏÑùÏóê ÌïÑÏöîÌïú Î∂ÑÎ•ò Ïª¨Îüº '{class_col}'ÏùÑ(Î•º) Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. DB ÌÖåÏù¥Î∏î Ïä§ÌÇ§ÎßàÎ•º ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî. ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ïª¨Îüº: {list(gdf.columns)}")
                            else:
                                st.warning("Î∂ÑÏÑù Ïú†ÌòïÏóê ÎåÄÌïú Î∂ÑÎ•ò Ïª¨ÎüºÏù¥ ÏßÄÏ†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.")

                    adjust_ax_limits(ax)
                    add_north_arrow(ax)
                    add_scalebar_vector(ax, dx=1.0)
                    ax.axis('off')
                    st.pyplot(fig)
                    plt.close(fig)  # Close figure to save memory
            else:
                st.info("ÏãúÍ∞ÅÌôîÌï† 2D Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.")

# --- 7. Summary and Downloads ---
st.markdown("### üìã ÏöîÏïΩ Î∞è Îã§Ïö¥Î°úÎìú")
st.markdown("#### ÏÉÅÏÑ∏ Î∂ÑÏÑù Î≥¥Í≥†ÏÑú")

summary_lines = []
summary_lines.append(f"Î∂ÑÏÑù ÏùºÏãú: {analysis_date}")
summary_lines.append(
    f"Î∂ÑÏÑù ÎåÄÏÉÅ: {st.session_state.get('uploaded_file_name', 'N/A')}")
if len(matched_sheets) > 20:
    summary_lines.append(
        f"ÏÇ¨Ïö©Îêú ÎèÑÏóΩ: {len(matched_sheets)}Í∞ú ({', '.join(matched_sheets[:20])}...)")
else:
    summary_lines.append(
        f"ÏÇ¨Ïö©Îêú ÎèÑÏóΩ: {len(matched_sheets)}Í∞ú ({', '.join(matched_sheets)})")
summary_lines.append("")

pixel_size = st.session_state.get('pixel_size', 1.0)
area_per_pixel = pixel_size * pixel_size

for analysis_type in valid_selected_types:
    stats = dem_results[analysis_type].get('stats')
    binned_stats = dem_results[analysis_type].get('binned_stats')
    gdf = dem_results[analysis_type].get('gdf')
    title_info = analysis_map.get(analysis_type, {})

    summary_lines.append(f"--- {title_info.get('title', analysis_type)} ---")
    if stats:
        unit = title_info.get('unit', '')
        total_area_m2 = stats.get('area', 0) * area_per_pixel
        summary_lines.append(f"- ÏµúÏÜåÍ∞í: {stats.get('min', 0):.2f} {unit}")
        summary_lines.append(f"- ÏµúÎåÄÍ∞í: {stats.get('max', 0):.2f} {unit}")
        summary_lines.append(f"- ÌèâÍ∑†Í∞í: {stats.get('mean', 0):.2f} {unit}")
        summary_lines.append(f"- Î∂ÑÏÑù Î©¥Ï†Å: {int(total_area_m2):,} m¬≤")

    if binned_stats:
        summary_lines.append(f"\n[{title_info.get('binned_label', 'Íµ¨Í∞ÑÎ≥Ñ ÌÜµÍ≥Ñ')}]")
        for row in binned_stats:
            binned_area_m2 = row['area'] * area_per_pixel
            summary_lines.append(
                f"- {row['bin_range']} {title_info.get('unit', '')}: {int(binned_area_m2):,} m¬≤")

    if gdf is not None and not gdf.empty:
        gdf['area'] = gdf.geometry.area
        class_col = title_info.get('class_col')
        if class_col and class_col in gdf.columns:
            summary = gdf.groupby(class_col)[
                'area'].sum().sort_values(ascending=False)
            summary_lines.append(
                f"\n[{title_info.get('binned_label', 'Ï¢ÖÎ•òÎ≥Ñ ÌÜµÍ≥Ñ')}]")
            for item, area in summary.items():
                summary_lines.append(f"- {item}: {int(area):,} m¬≤")
        else:
            summary_lines.append(f"- Ï¥ù Î∂ÑÏÑù Î©¥Ï†Å: {int(gdf.area.sum()):,} m¬≤")
            if class_col:
                summary_lines.append(
                    f"- (ÏÉÅÏÑ∏ Î©¥Ï†Å ÌÜµÍ≥ÑÎ•º Í≥ÑÏÇ∞ÌïòÎ†§Î©¥ '{class_col}' Ïª¨ÎüºÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.)")

    summary_lines.append("")

summary_text = "\n".join(summary_lines)
st.text_area("Î∂ÑÏÑù Í≤∞Í≥º ÏöîÏïΩ", summary_text, height=300)
st.download_button("Î∂ÑÏÑù Í≤∞Í≥º(.txt) Îã§Ïö¥Î°úÎìú", summary_text, "analysis_summary.txt")


# --- 8. Footer ---
st.markdown("---_---")
if st.button("ÏÉàÎ°úÏö¥ Î∂ÑÏÑù ÏãúÏûëÌïòÍ∏∞"):
    for key in list(st.session_state.keys()):
        if key not in ['upload_counter']:
            del st.session_state[key]
    st.switch_page("app.py")

